import numpy as np
import pandas as pd

import arviz as az
import pymc3 as pm
import theano.tensor as tt
import theano

from covid19_pytoolbox.modeling import Rt

def MCMC_sample(
    onset, 
    alpha, 
    beta, 
    rel_eps=None,
    eps_window=7,
    onset_local=None,
    start=0, window=None, 
    chains=1, tune=4000, draws=4000, 
    target_accept=0.95, 
    max_treedepth=10,
    dry=False, 
    cores=None,
    progressbar=True
):
    """
    Perform the Markov Chain Monte Carlo simulation to draw Rt values from the new cases distributions

    Args:
        onset (pd.Series or ndarray): the smoothed series of total cases (total = local+imported)
        alpha (float): parameter for the gamma distribution of 'w'
        beta (float): parameter for the gamma distribution of 'w'
        rel_eps (ndarray, optional): the series of relative residuals among the onset and the onset and the raw cases. Defaults to None
        eps_window (int, optional): the number of days to take the rolling and and std std on to sample noise. Defaults to 7
        onset_local (pd.Series or ndarray, optional): the smoothed series of local cases. Defaults to None
        start (int, optional): the number of das to start from the beginning. Defaults to 0
        window (int, optional): the number of days to take into account after start. If None take all. Defaults to None
        chains (int, optional): number of chains to sample. Defaults to 1
        tune (int, optional): The number of samples to drop for tuning. Defaults to 4000
        draws (int, optional): The number of samples to draw after tuning. Defaults to 4000
        target_accept (float, optional): The target_accept param of pymcmc. Defaults to 0.95
        max_treedepth (int, optional): The max_treedepth param of pymcmc. Defaults to 10
        dry (bool, optional): if True build the model without sampling. Defaults to False
        cores (int, optional): The number of cores to use for sampling. Defaults to None
        progressbar (bool, optional): shot the progressbar of pymcmc. Defaults to True
    """

    if not window:
        window = len(onset)
        
    if type(onset)==pd.DataFrame:
        onset = onset.values
        
    onset_ = onset[start:start+window]

    # we fill nans created by the rolling std with small fixed values
    # as pymc can't draw samples from 0. standard deviation
    # this is going to affect only the very beginning of the series, which we are not interested into
    fill_std = 10.**(-3)
    fill_mean = 0.

    if not rel_eps is None:
        rel_eps_ = rel_eps[start:start+window]
        rel_eps_mean = pd.Series(rel_eps_).rolling(window=eps_window).mean().fillna(fill_mean).to_numpy()
        rel_eps_std = pd.Series(rel_eps_).rolling(window=eps_window).std().fillna(fill_std).to_numpy()

    # skip the first as we can't compute Rt on the first day
    observed = (onset_[1:]).round()

    if not onset_local is None:
        if type(onset_local)==pd.DataFrame:
            onset_local = onset_local.values
        onset_local_ = onset_local[start:start+window]

        # if we take into account the difference between local and total cases 
        #   where total = local + imported
        # then the observed must match the local cases
        # as the observed are the effective cases generated by previous cases
        observed = (onset_local_[1:]).round()

    steps = len(onset_)
    x = np.linspace(1,steps-1, steps)
    w = Rt.naive.gamma_df(x, alpha, beta)    
    
    with pm.Model() as model:
                
        # draws R_t from a prior normal distribution
        # shape-1 as we don't have Rt on the first day
        r_t = pm.Normal("r_t", mu=1.3, sigma=10., shape=len(onset_)-1)

        if not rel_eps is None:
            # sample noise from deseason epsilons and add it to the onsets
            rel_residuals = pm.Normal(
                name="rel_residuals", 
                mu=rel_eps_mean, 
                sigma=rel_eps_std,
                shape=len(rel_eps_std)
            )
            onset_residuals = pm.Deterministic(
                "onset_residuals", 
                onset_ + onset_ * rel_residuals
            )
        else:
            onset_residuals = onset_
        
        # compute the exptected number of current infectious 
        # based on the sampled R_t and the know past values of infectious
        
        # this is the Theano implementation of the function in 
        # modeling.Rt.naive.infectious_charge
        # the infectious charge must be computed on the total=local+imported cases
        # since these are the effective previous cases which can generate new ones
        infectious_charge_ = pm.Deterministic(
            "infectious_charge",
            tt.as_tensor([
                tt.sum(onset_residuals[t-1::-1]*w[:t]) 
                for t in range(1, steps)        
            ])            
        )         

        # estimate the expected today based on Rt esimate
        expected_today = r_t * infectious_charge_ 
        
        # Poisson requirements
        mu = pm.math.maximum(.1, expected_today)

        # test the posterior: 
        # mu values derived from R_t samples 
        # must converge to the mean of real cases 
        # if they are Poisson distributed, as they are
        cases = pm.Poisson('cases', mu=mu, observed=observed)

        trace = None
        if not dry:
            trace = pm.sample(
                chains=chains,
                cores=cores,
                tune=tune,
                draws=draws,
                target_accept=target_accept, max_treedepth=max_treedepth,
                progressbar=progressbar)
            
    return model, trace